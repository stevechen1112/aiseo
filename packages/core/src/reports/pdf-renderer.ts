/**
 * PDF report generation using Playwright (headless Chromium).
 * Renders an HTML template to PDF with white-label branding support.
 * Falls back to a minimal text-based PDF when browser is not available.
 */

export interface PdfRenderInput {
  html: string;
  headerHtml?: string;
  footerHtml?: string;
  format?: 'A4' | 'Letter';
  landscape?: boolean;
  margin?: { top?: string; right?: string; bottom?: string; left?: string };
}

export interface WhiteLabelConfig {
  companyName: string;
  logoUrl?: string;
  primaryColor?: string;
  secondaryColor?: string;
  footerText?: string;
}

/**
 * Creates an HTML report from structured data with white-label branding.
 */
export function buildReportHtml(options: {
  title: string;
  sections: Array<{ heading: string; content: string }>;
  branding?: WhiteLabelConfig;
  dateRange?: { start: string; end: string };
}): string {
  const { title, sections, branding, dateRange } = options;
  const primaryColor = branding?.primaryColor ?? '#3b82f6';
  const companyName = branding?.companyName ?? 'AISEO Platform';
  const logoHtml = branding?.logoUrl
    ? `<img src="${branding.logoUrl}" alt="${companyName}" style="max-height:60px;" />`
    : `<h2 style="color:${primaryColor};margin:0;">${companyName}</h2>`;
  const dateRangeHtml = dateRange
    ? `<p style="color:#6b7280;font-size:14px;">${dateRange.start} â€” ${dateRange.end}</p>`
    : '';

  const sectionHtml = sections
    .map(
      (s) => `
    <div style="margin-bottom:24px;">
      <h2 style="color:${primaryColor};border-bottom:2px solid ${primaryColor};padding-bottom:8px;">${s.heading}</h2>
      <div>${s.content}</div>
    </div>
  `,
    )
    .join('\n');

  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 40px; color: #1f2937; }
    table { width: 100%; border-collapse: collapse; margin: 12px 0; }
    th, td { border: 1px solid #e5e7eb; padding: 8px 12px; text-align: left; font-size: 13px; }
    th { background: ${primaryColor}; color: white; }
    .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 32px; padding-bottom: 16px; border-bottom: 3px solid ${primaryColor}; }
    .footer { margin-top: 40px; padding-top: 16px; border-top: 1px solid #e5e7eb; text-align: center; font-size: 12px; color: #9ca3af; }
  </style>
</head>
<body>
  <div class="header">
    <div>${logoHtml}</div>
    <div style="text-align:right;">
      <h1 style="margin:0;font-size:22px;">${title}</h1>
      ${dateRangeHtml}
    </div>
  </div>
  ${sectionHtml}
  <div class="footer">
    ${branding?.footerText ?? `Generated by ${companyName}`} | ${new Date().toISOString().slice(0, 10)}
  </div>
</body>
</html>`;
}

/**
 * Renders HTML to PDF using Playwright's Chromium browser.
 * Requires `playwright` to be installed.
 */
export async function renderHtmlToPdf(input: PdfRenderInput): Promise<Buffer> {
  // Dynamic import to avoid hard dependency when browser is not available
  const { chromium } = await import('playwright');
  const browser = await chromium.launch({ headless: true });
  try {
    const page = await browser.newPage();
    await page.setContent(input.html, { waitUntil: 'networkidle' });

    const pdfBuffer = await page.pdf({
      format: input.format ?? 'A4',
      landscape: input.landscape ?? false,
      margin: input.margin ?? { top: '20mm', bottom: '20mm', left: '15mm', right: '15mm' },
      displayHeaderFooter: !!(input.headerHtml || input.footerHtml),
      headerTemplate: input.headerHtml ?? '',
      footerTemplate: input.footerHtml ?? '',
      printBackground: true,
    });

    return Buffer.from(pdfBuffer);
  } finally {
    await browser.close();
  }
}

/**
 * Minimal fallback PDF generator (no browser needed).
 * Used when Playwright/Chromium is not available.
 */
export function createMinimalPdf(text: string): Buffer {
  const safe = text.replace(/[^\x20-\x7E\n]/g, '?');
  const lines = safe.split('\n').slice(0, 50); // Max 50 lines
  let yPos = 750;
  const lineHeight = 16;
  let contentStream = '';

  for (const line of lines) {
    const escaped = line.replace(/\(|\)|\\/g, (m) => `\\${m}`);
    contentStream += `BT\n/F1 11 Tf\n72 ${yPos} Td\n(${escaped}) Tj\nET\n`;
    yPos -= lineHeight;
    if (yPos < 50) break;
  }

  const objects: string[] = [];
  objects.push('1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n');
  objects.push('2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n');
  objects.push(`3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>\nendobj\n`);
  objects.push(`4 0 obj\n<< /Length ${contentStream.length} >>\nstream\n${contentStream}endstream\nendobj\n`);
  objects.push('5 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n');

  let offset = 0;
  const header = '%PDF-1.4\n';
  offset += header.length;
  const xref: number[] = [0];

  let body = '';
  for (const obj of objects) {
    xref.push(offset);
    body += obj;
    offset += obj.length;
  }

  const xrefStart = offset;
  let xrefTable = `xref\n0 ${objects.length + 1}\n`;
  xrefTable += '0000000000 65535 f \n';
  for (let i = 1; i < xref.length; i++) {
    xrefTable += `${String(xref[i]).padStart(10, '0')} 00000 n \n`;
  }

  const trailer = `trailer\n<< /Size ${objects.length + 1} /Root 1 0 R >>\nstartxref\n${xrefStart}\n%%EOF\n`;
  const pdf = header + body + xrefTable + trailer;
  return Buffer.from(pdf, 'utf8');
}
